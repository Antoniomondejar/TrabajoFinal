\chapter{Introducción}

La lógica y las ciencias de la computación han estado en contacto y en constante desarrollo a lo largo de la historia. Desde los años 1930
con la búsqueda de un procedimiento para determinar mecánicamente la validez de una sentencia matemática, hasta 
hoy en día donde abunda el uso de métodos formales en áreas de verificación de software e inteligencia artificial, estas dos disciplinas 
científicas no han dejado de nutrirse mutuamente.

% \medskip
Como se menciona en \cite{HalpernHIKVV01}, la lógica ha resultado fundamental en numerosas áreas de las ciencias de la computación. 
Un clásico ejemplo es la rama de la complejidad descriptiva, que busca establecer relaciones entre la complejidad intrínseca 
de los problemas computacionales y la dificultad de expresar una propiedad mediante una fórmula lógica. Un resultado que evidencia el enorme
potencial de esta propuesta es el Teorema de Fagin \cite{Fagin}, el cual establece que los problemas computacionales para los que se pueden 
verificar sus soluciones eficientemente (la clase \NP) son exactamente aquellos que pueden expresarse con una fórmula existencial de segundo 
orden, lo que permite determinar cotas superiores de dificultad computacional sin la necesidad de encontrar un algoritmo. Otros ejemplos 
relacionados con áreas prácticas de la computación incluyen el uso de variaciones sintácticas de lógica de primer orden como 
lenguajes de consulta de bases de datos y de herramientas de model-checking en verificación formal de sistemas.  
% \medskip

También se ha explorado el uso de formalismos lógicos para modelar nociones más abstractas vinculadas al razonamiento y la información.  
El ejemplo que constituye las bases teóricas en las que surge este trabajo es el de las lógicas epistémicas. Estas permiten representar 
y razonar formalmente sobre el conocimiento de agentes, los cuales modelan entidades autónomas que actúan e interactúan en un determinado escenario. 
De esta forma, podemos expresar propiedades tales como ``Juan sabe que está 
lloviendo en Río Cuarto'', en la que el valor de verdad de la propiedad no solo depende de si efectivamente llueve en Río Cuarto sino 
también del conocimiento de Juan acerca del hecho. Así, las lógicas epistémicas proveen una base para el análisis de preguntas como: ¿Qué necesita 
saber un robot para cumplir un objetivo? ¿Qué necesita saber un agente acerca de los demás agentes para convencerlos de un argumento?, las cuales resultan
de interés en disciplinas como la planificación en inteligencia artificial o la teoría de la argumentación.
% \medskip

La semántica para este tipo de lógicas está basada en la noción de \textit{mundos posibles}. Dada la información actual 
que posee un agente existe una cierta cantidad de mundos posibles que podrían representar el estado actual de los hechos. 
Luego, un agente \textit{sabe} una propiedad si la misma es cierta en todos los mundos que considera que son posibles. 
La representación matemática por excelencia de este concepto está dada por los modelos relacionales (o de Kripke),
los cuales son grafos dirigidos en los que sus estados, etiquetados con un conjunto de variables proposicionales, representan los distintos 
mundos posibles y una arista $(w,v)$ con etiqueta $i$ determina que en el mundo $w$ el agente $i$ considera posible al mundo $v$.
De esta forma, es posible representar numerosos sistemas de múltiples agentes interactuando entre sí: jugadores en una partida 
de póker, usuarios comunicándose en una red social, participantes de un debate, entre otros.
% \medskip

Las propuestas clásicas de lógicas epistémicas consideran el conocimiento de los agentes en la forma de ``saber qué'' (\textit{knowing that}, \cite{Hintikka1962}), 
concentrandose así en el estudio de propiedades como las que fueron mencionadas anteriormente. Sin embargo, en años recientes se han desarrollado 
teorías y lenguajes formales en torno a otras formas del conocimiento. Algunos autores han estudiado la noción de ``saber si'' 
(\textit{knowing whether}, \cite{KnowingWhether}), donde el conocimiento de los agentes está relacionado con su certeza en relación al 
valor de verdad de una proposición; 
otros la noción de ``saber por qué'' (\textit{knowing why}, \cite{KnowingWhy}), en la que se consideran las razones y justificaciones 
del conocimiento. 
Por último, la forma del conocimiento en la que nos centramos durante todo este trabajo es la que se enfoca principalmente en las habilidades 
de los agentes: la noción de ``saber cómo'' (\textit{knowing how}, \cite{Wang15KH,ArecesFSV25}). Esta nos permite formalizar expresiones como 
``el agente $i$ sabe cómo garantizar la propiedad $\varphi$ cuando se encuentra en una situación en la que se da la propiedad 
$\psi$''. En esta propuesta, las habilidades de los agentes están sujetas a las acciones que los mismos consideran posibles (o dicho de otra 
manera, que saben que tienen a su disposición), y a la forma en la que consiguen 
combinarlas para alcanzar un determinado objetivo. Por este motivo, esta noción es considerada a la hora de 
formalizar problemas relacionados al razonamiento estratégico y la planificación automática.
% \medskip

En \cite{Wang15KH,Wang2018GoalDirectedKH} se introduce el lenguaje formal \KHlogic con el objetivo de matematizar 
las ideas presentadas en relación a la noción de ``saber cómo'', en el contexto de sistemas de un único agente. Como en las primeras 
lógicas epistémicas, \KHlogic también se interpreta sobre modelos relacionales, vistos en este caso como sistemas de transición de estados 
(\lts por sus siglas en inglés). Sin embargo, en este contexto las aristas de los \ltss no representan la 
indistinguibilidad del agente sobre los distintos mundos posibles sino que describen los cambios de estado que producen las acciones 
que este puede ejecutar. De esta forma, una arista $(w,v)$ con etiqueta $a$ indica que cuando el agente 
se encuentra en el estado $w$ puede ejecutar la acción $a$ para terminar en el estado $v$. Luego, dado un \lts el agente sabe 
cómo garantizar $\varphi$ a partir de una condición inicial $\psi$ cuando existe un plan \textit{adecuado} que, al ser ejecutado a 
partir de cualquier estado en el que vale $\psi$, lleve únicamente a estados donde vale $\varphi$. Un plan se considera \textit{adecuado} 
cuando es \textit{fuertemente ejecutable}, concepto que explicaremos en mayor detalle en los próximos capítulos.
% \medskip

Nótese que en el contexto de \KHlogic se asume, por ejemplo, que toda composición de acciones está dentro del espectro de 
habilidades del agente en cuestión. Por este motivo, la única situación en la que un agente no sabe cómo lograr un objetivo se da cuando no 
existe un plan que lo garantice. Sin embargo, en un escenario más realista, podría darse el caso en el que el agente conozca las acciones 
de un \lts pero no sepa cómo componerlas para construir un plan adecuado. Más aún, el agente podría ser consciente de la existencia de 
dos planes distintos pero no tener la capacidad de distinguir los efectos que estos provocan.
% \medskip

Así es como surge la propuesta de \cite{ArecesFSV25,SaraviaPHD} de la Lógica de \textit{Knowing How} Basada en la Incertidumbre (\KHilogic), 
en la que la estrategia utilizada para abordar las consideraciones mencionadas es extender los \ltss con una relación de indistinguibilidad sobre 
planes. De esta forma, la habilidad del agente deja de depender únicamente de las posibles composiciones de acciones y pasa a tenerse en 
consideración su percepción sobre las mismas y su capacidad de distinguir los distintos 
resultados que estas podrían provocar. A su vez, esta propuesta permite la representación de sistemas de múltiples agentes, en donde 
todos actúan en un mismo contexto pero cada uno cuenta con su propia percepción.
% \medskip

El estudio sistemático de propiedades de la lógica \KHilogic ya fue realizado en \cite{ArecesFSV25,SaraviaPHD}, así como también una 
justificación exhaustiva de las decisiones tomadas a la hora de diseñarla. Entre las propiedades investigadas, aparece un análisis de su 
poder expresivo. En general, el poder expresivo de una lógica se mide en términos de su capacidad para distinguir modelos con diferentes 
características estructurales. En este contexto, se vuelve necesario definir una noción de equivalencia de 
modelos para determinar hasta qué punto la lógica en cuestión considera a dos modelos iguales. Decimos que dos modelos 
son equivalentes en relación a una lógica cuando satisfacen exactamente las mismas fórmulas. Luego, si la lógica nos permite 
expresar propiedades relacionadas al \textit{comportamiento} de un modelo, dos modelos serán equivalentes cuando no puedan ser distinguidos 
por este tipo de propiedades, es decir, cuando tengan el mismo \textit{comportamiento}. Un desafío que surge naturalmente a partir de este 
concepto es el de caracterizar esta noción de manera puramente semántica. Así es como 
surgen nociones de equivalencia de modelos que consideran únicamente características estructurales de los mismos;
evitando así la necesidad de objetos sintácticos, como lo son las fórmulas, para identificar modelos con el mismo comportamiento.

Para el caso de los lenguajes modales, la noción de \textit{bisimulación}\cite[Capítulo 3]{HandbookModalLogic} viene a servir este propósito. A pesar de que cada lógica modal 
tiene su propia definición, la mayoría comparte la misma idea general: una bisimulación es una relación binaria entre 
los dominios de dos \ltss en la que dos estados se relacionan sólo si satisfacen ciertas condiciones relacionadas a la 
estructura de los \ltss en cuestión. Por su lado, las condiciones requeridas en cada definición de bisimulación se eligen con el objetivo 
principal de garantizar que todo par de \ltss bisimilares es también un par de \ltss lógicamente equivalentes. En contextos de aplicación 
práctica de las lógicas modales, como la verificación de software, ciertos problemas computacionales relacionados con la noción de bisimulación 
se tornan cruciales. En particular, al utilizar \ltss para representar sistemas de computación, problemas como el de verificar si dos 
\ltss son bisimilares o el de minimizar un \lts (encontrar el \lts de tamaño mínimo que sea lógicamente equivalente) permiten determinar 
cuando dos sistemas satisfacen las mismas propiedades y obtener 
una representación de tamaño mínimo de un sistema que mantenga las características estructurales de mayor relevancia.  

La noción de bisimulación para \KHlogic se presenta en \cite{FervariVQW21}. Posteriormente, en \cite{ArecesFSV25,SaraviaPHD} se 
extiende esta definición para \KHilogic donde se considera la relación de indistinguibilidad sobre planes de los agentes introducida 
en el contexto de este lenguaje formal. Una observación que surge a partir de las definiciones propuestas para ambas lógicas es que 
establecen condiciones sobre los conjuntos \textit{proposicionalmente definibles} de los \ltss involucrados, los cuales son conjuntos 
identificados unívocamente por una fórmula proposicional. Esto contradice la esencia puramente estructural de las bisimulaciones, pues 
requiere de la existencia de objetos sintácticos.
% \bigskip

En este trabajo contribuimos al estudio de la noción de bisimulación de \KHilogic desde un punto de vista computacional. 
En primera instancia, proponemos una nueva definición para este concepto con el objetivo de otorgarle una 
naturaleza más algorítmica y mejor alineada con las bisimulaciones clásicas, las cuales únicamente consideran 
características estructurales de los objetos matemáticos involucrados. Además, demostramos que nuestra propuesta satisface las propiedades 
esperadas de correctitud.
Luego, estudiamos problemas computacionales relacionados con esta noción. Por un lado, caracterizamos la complejidad de 
determinar si una relación binaria es una bisimulación y, por otro lado, la complejidad de decidir la existencia 
de una bisimulación entre dos modelos. En particular, demostramos que los problemas mencionados son \coNPCompletes. Por último, 
abordamos el problema de la minimización de modelos para \KHilogic a partir 
de la definición de contracciones por bisimulación.
Este análisis computacional no solo es realizado con el objetivo de determinar la factibilidad de este lenguaje formal en aplicaciones 
prácticas sino que también para expandir el entendimiento a nivel conceptual de los objetos matemáticos 
considerados y, de esta manera, fortalecer el argumento a favor del estudio de aspectos computacionales en ámbitos propios de la lógica.

\bigskip\bigskip
\ssparagraph{\Large{Estructura del trabajo}}
\bigskip

En el \Cref{ch:marco-teorico} presentamos la Lógica de \textit{Knowing How} Basada en la Incertidumbre (\KHilogic). 
Primero, introducimos su sintaxis y semántica; para ello presentamos la gramática que define las fórmulas que la componen y 
los modelos sobre los que se interpreta junto con algunas convenciones notacionales. A continuación, presentamos la noción de bisimulación 
definida para esta lógica junto con sus principales propiedades. Finalmente, terminamos 
el capítulo mencionando algunos de los principales resultados referidos a la complejidad computacional de \KHilogic.

En el \Cref{ch:redef-bisim} proponemos una nueva definición de bisimulación para \KHilogic. En primer lugar, caracterizamos los 
conjuntos proposicionalmente definibles del dominio de un modelo a partir de su función de valuación, lo que nos permite establecer una correspondencia 
con la anterior definición de bisimulación y, de esta manera, demostrar el Teorema de Invarianza por Bisimulación para la nueva definición.  
Luego, fortalecemos la caracterización de los conjuntos proposicionalmente definibles para la clase de modelos con dominio finito, lo que 
nos permite demostrar que esta clase satisface la propiedad Hennessy-Milner con respecto a la nueva definición. A su vez, a partir de este 
fortalecimiento determinamos que el problema de definibilidad para \KHilogic está en la clase de complejidad \Poly.

En el \Cref{ch:khi-bisim} estudiamos problemas computacionales relacionados con la noción de bisimulación. En primera instancia, demostramos 
que el problema de determinar si una relación binaria es una bisimulación es \coNPComplete. Para ello, presentamos un algoritmo eficiente de 
verificación de certificados que decide su complemento y, a su vez, reducimos polinomialmente el problema de decidir si una fórmula 
proposicional en forma disyuntiva normal es una tautología. Luego, extendemos este resultado al problema de decidir la existencia de una 
bisimulación entre dos modelos y a la versión punteada del mismo. Por último, presentamos una forma de modificar el algoritmo propuesto 
en este capítulo para que sea capaz de computar una fórmula de tamaño polinomial que distingue a los modelos recibidos por input en caso de 
no ser bisimilares. 

En el \Cref{ch:contraccion} abordamos el problema de minimización de modelos para \KHilogic, para el cual presentamos dos propuestas de 
contracción por bisimulación. La primera de ellas surge de la caracterización de la máxima autobisimulación de un modelo y, la segunda 
se construye a partir de la contracción por bisimulación clásica de la Lógica Modal Básica. Para ambas propuestas demostramos los 
resultados esperados de correctitud y establecemos que son computables en tiempo polinomial. Por último, terminamos este capítulo con 
un análisis sobre las características de cada propuesta junto ejemplos que evidencian la naturaleza de ambas.

En el \Cref{ch:conclusiones} presentamos algunas conclusiones generales junto con una recapitulación de lo estudiado a lo largo del trabajo.
También, mencionamos posibles líneas de investigación a futuro que surgen naturalmente de los resultados obtenidos en esta tesis.
